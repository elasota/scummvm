GUID resolution and structure loading:

Loading of objects in the mTropolis backend is done in multiple stages due to
the complex GUID resolution process, inline assets, and other things.

The first step to loading is to load data objects.  Data objects are JUST data,
but due to weird aspects of the data loading process (like the fact that asset
defs can appear anywhere) it's separate.

The second step is conversion of data objects into runtime objects and
formation of the scene structure.

The third step is "materialization" which converts loaded objects into a
ready-to-use state.  This involves replacing any non-variable aliases with a
copy of the original, and assigning new GUIDs to the new objects.

Objects are only ever materialized once.  Aliasable variables in the global
modifier table are materialized when the project is loaded, while everything
else is materialized when it's imported into the project.

Objects cloned from already-materialized objects should NOT be materialized
again, instead they should be fixed up using an object reference remap table,
shallowClone, and visitInternalReferences.  Cloning is not currently supported
because Obsidian doesn't use it.

An important aspect of this loading process that GUIDs are resolved in the
scope of where they are inserted.  This is necessary because mTropolis allows
objects to be converted into aliases anywhere that they occur and will NOT
do anything to patch up GUID references from where they were, so the GUID
needs to be resolvable from the location that the modifier exists.



Scene transitions:

mTropolis Player's handling of scene transitions is very buggy/quirky.
Basically, there is a feature called "add to destination scene" (ATDS) which
loads the target scene on top of a stack of scenes and adds it to the return
list, which is intended for dialogs and such.

Unfortunately, it only works properly in the straightforward case, and
transitions are done in a way that basically does the exact actions required
for it to work in the typical case but are broken in edge cases.

Basically scenes are ordered in a stack, and there is a scene return list
separate from the scene stack.  The shared scene is always at the bottom of
the stack.

On forward scene transitions:
 - The shared scene is changed to the shared scene of the new scene
 - If not doing an ATDS-type transfer, then the current scene is unloaded
 - If the target scene is not loaded, then it is loaded at the top of the stack

On return transitions:
 - The active scene is unloaded
 - If returning from a non-ATDS transfer, then the return scene is loaded and its
   shared scene is made active.

This has a bunch of confirmed broken cases:
- Returning from an ATDS transfer into a different shared scene will not reset
  the shared scene on return.
- Transitioning into an ATDS scene that's already in the stack will cause it to
  be removed on returning.  This can even cause no scenes to be loaded.
- Doing a regular transition out of ATDS stacked scenes and then returning will
  cause only the top scene to be loaded.
- Transitioning to the shared scene causes very nonsensical behavior, including
  doubled-up events, modifiers not working, and other chaos.  Currently the
  mTropolis engine errors out if you attempt this.
- Probably a bunch of other cases.


Object reference liveness:

A lot of things internally go off of an assumption that structural objects and
modifiers are NEVER deleted unless the VThread task queue is empty.  Basically that
means that if any messages are queued or any actions are in the middle of being
performed, then objects may not be deleted.  The only thing that can delete an
object is a scheduled Teardown.

Currently this is unused, but mTropolis supports a "kill" event type which will
remove an object when sent to it, and a "kill" attribute that removes an object
when it is assigned to.

A big implication of this is that it's okay to use raw pointers to scene objects
in VThread tasks.  In particular, tasks calling member functions are OK to
schedule.
